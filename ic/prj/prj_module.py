#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Модуль классов узлов модулей проекта.
"""

# Подключение библиотек
import wx
from wx.lib.agw import flatmenu
import os
import os.path
import shutil
# import imp
import ic.utils.impfunc
from ic.imglib import common as imglib
from ic.utils import ic_file
from ic.utils import ic_res
from ic.utils import util
from ic.dlg import ic_dlg
from ic.editor import ext_python_editor
from ic.log import log
from ic.editor import wxfb_manager

from . import prj_node
from . import prj_resource
from . import prj_fb
from . import prj_xrc
from . import prj_wxcp

__version__ = (0, 1, 3, 1)

_ = wx.GetTranslation

# Управлене функционалом системы
# Сигнатура интерфейсного модуля
INTERFACE_MODULE_SIGNATURE = '###BEGIN SPECIAL BLOCK'
# Сигнатура ресурсонго модуля
RESOURCE_MODULE_SIGNATURE = '### RESOURCE_MODULE:'
# Сигнатура модуля шаблона
TEMPLATE_MODULE_SIGNATURE = '### TEMPLATE_MODULE:'
# Сигнанура модуля библиотки образов
IMAGE_MODULE_SIGNATURE = '# --- Image Library File ---'
# Сигнанура модуля прототипа форм сгенерированнх wxFormBuilder
WXFB_MODULE_SIGNATURE = '## Python code generated with wxFormBuilder'
# Сигнатура модуля прототипа форм сгенерированного pywxrc утилитой (из XRC ресурса)
XRC_MODULE_SIGNATURE = '# This file was automatically generated by pywxrc.'


class icPrjModules(prj_node.icPrjFolder):
    """
    Функционал.
    """

    def __init__(self, parent=None):
        """
        Конструктор.
        """
        prj_node.icPrjFolder.__init__(self, parent)
        self.img_extended = imglib.imgFolderOpen
        self.description = u'Модули'
        self.name = u'Модули'
        self.include_nodes = [icPrjModule,
                              prj_fb.icPrjWXFormBuilderProject,
                              prj_xrc.icPrjXRCResource,
                              prj_wxcp.icPrjWXCrafterProject,
                              prj_resource.icPrjTabRes, prj_resource.icPrjDBRes,
                              prj_resource.icPrjFrmRes, prj_resource.icPrjWinRes,
                              prj_resource.icPrjMenuRes, prj_resource.icPrjTemplate,
                              prj_resource.icPrjMethod]
        self.include_folder = icPrjPackage

    def onNodePopup(self, event):
        """
        Вызов всплывающего меню узла.
        """
        from . import menuModNode

        popup_menu = menuModNode.icMenuModNode(self)
        popup_menu.Popup(wx.GetMousePosition(), self._root.getParent())

    def _getPrjFileList(self, path):
        """
        Получить отсортированный список файлов и подпапок по пути.
        Порядок сортировки: Сначала папки отсортированные по имени,
        затем файлы отсортированные по имени.
        @param path: Текущая папка-пакет.
        @return:
        """
        # Обработка подпапок
        file_list = [os.path.join(path, cur_file) for cur_file in os.listdir(path)]
        dir_list = [file_name for file_name in file_list if self.isPackage(file_name)]
        dir_list.sort()
        # Обработка списка файлов
        py_file_list = [file_name for file_name in file_list if self.isFBP(file_name) or
                        self.isXRC(file_name) or
                        self.isWXCP(file_name) or
                        self.isModule(file_name) or
                        self.isInterfaceModule(file_name) or
                        self.isResourceModule(file_name)]
        py_file_list.sort()

        # Объединить два отсортированных списка
        all_path_list = dir_list + py_file_list
        return all_path_list

    def buildPrjPy(self, path):
        """
        Построение всех узлов/py-модулей проекта.
        @param path: Текущая папка-пакет/py-модуль.
        """
        # Обработка подпапок
        all_path_list = self._getPrjFileList(path)
        for py_path in all_path_list:
            self.buildPyTree(self, py_path)

    def _findModuleSignature(self, module_name, signature):
        """
        Проверка есть ли в модуле сигнатура?
        @param module_name: Имя модуля.
        @param signature: Текст сигнатуры.
        @return: Возвращает True/False.
        """
        find = False
        module_file = None
        try:
            module_file = open(module_name, 'rt')
            text = module_file.read()
            module_file.close()
            return text.find(signature) != -1
        except:
            log.fatal(u'Ошибка поиска сигнатуры <%s> в модуле <%s>.' % (signature, module_name))
            if module_file:
                module_file.close()
        return False
        
    def isModule(self, filename):
        """
        Проверка является ли файл модулм проекта.
        @param filename: Имя файла.
        @return: Возвращает True/False.
        """
        return os.path.isfile(filename) and \
               (os.path.splitext(filename)[1] == '.py' and
                os.path.basename(filename) != '__init__.py') and \
               (not self._findModuleSignature(filename, INTERFACE_MODULE_SIGNATURE))

    def isFBP(self, filename):
        """ 
        Проверка является ли файл модулм проекта wxformbuilder.
        @param filename: Имя файла.
        @return: Возвращает True/False.
        """
        return os.path.isfile(filename) and \
               (os.path.splitext(filename)[1] == '.fbp')

    def isWXCP(self, filename):
        """
        Проверка является ли файл модулем проекта wxCrafter.
        @param filename: Имя файла.
        @return: Возвращает True/False.
        """
        return os.path.isfile(filename) and \
               (os.path.splitext(filename)[1] == '.wxcp')

    def isXRC(self, filename):
        """
        Проверка является ли файл XRC ресурсом форм.
        @param filename: Имя файла.
        @return: Возвращает True/False.
        """
        return os.path.isfile(filename) and \
               (os.path.splitext(filename)[1] == '.xrc') and \
               not filename.endswith('_forms_bitmaps.xrc')
        #                                ^
        # Исключаем файл ресурсов картинок, генерируемые wxCrafter

    def isInterfaceModule(self, filename):
        """
        Проверка является ли файл интерфейсным модулем проекта.
        @param filename: Имя файла.
        @return: Возвращает True/False.
        """
        return os.path.isfile(filename) and \
               (os.path.splitext(filename)[1] == '.py' and \
                os.path.basename(filename) != '__init__.py') and \
               self._findModuleSignature(filename, INTERFACE_MODULE_SIGNATURE)
            
    def isResourceModule(self, filename):
        """
        Проверка является ли файл ресурсным модулем проекта.
        @param filename: Имя файла.
        @return: Возвращает True/False.
        """
        return os.path.isfile(filename) and \
               (os.path.splitext(filename)[1] == '.py' and \
                os.path.basename(filename) != '__init__.py') and \
               self._findModuleSignature(filename, RESOURCE_MODULE_SIGNATURE)
            
    def isImageModule(self, filename):
        """
        Проверка является ли файл модулем библиотеки образов проекта.
        @param filename: Имя файла.
        @return: Возвращает True/False.
        """
        return os.path.isfile(filename) and \
               (os.path.splitext(filename)[1] == '.py' and \
                os.path.basename(filename) != '__init__.py') and \
               self._findModuleSignature(filename, IMAGE_MODULE_SIGNATURE)

    def isFBModule(self, filename):
        """
        Проверка является ли файл модулем форм wxFormBuilder.
        @param filename: Имя файла.
        @return: Возвращает True/False.
        """
        return os.path.isfile(filename) and \
               (os.path.splitext(filename)[1] == '.py' and
                os.path.basename(filename) != '__init__.py') and \
               self._findModuleSignature(filename, WXFB_MODULE_SIGNATURE)

    def isXRCModule(self, filename):
        """
        Проверка является ли файл модулем форм,
        сгенерированных утилитой pywxrc (из XRC ресурса).
        @param filename: Имя файла.
        @return: Возвращает True/False.
        """
        return os.path.isfile(filename) and \
               (os.path.splitext(filename)[1] == '.py' and
                os.path.basename(filename) != '__init__.py') and \
               self._findModuleSignature(filename, XRC_MODULE_SIGNATURE)

    def isTemplateModule(self, filename):
        """
        Проверка является ли файл модулем шаблона проекта.
        @param filename: Имя файла.
        @return: Возвращает True/False.
        """
        return os.path.isfile(filename) and \
               (os.path.splitext(filename)[1] == '.py' and \
                os.path.basename(filename) != '__init__.py') and \
               self._findModuleSignature(filename, TEMPLATE_MODULE_SIGNATURE)
            
    def isPackage(self, directory):
        """
        Проверка является ли директория пакетом проекта.
        @param directory: Указание директории.
        @return: Возвращает True/False.
        """
        is_dir = os.path.isdir(directory)
        is_in_prj = False
        is_init_file = False
        if is_dir:
            is_in_prj = ic_file.IsSubDir(directory, os.path.dirname(self.getRoot().getPrjFileName()))
            is_init_file = os.path.exists(os.path.join(directory, '__init__.py'))
        is_sub_sys = False
        return is_dir and is_in_prj and is_init_file and (not is_sub_sys)
        
    def buildPyTree(self, cur_package, path):
        """
        Построение всех узлов/py-модулей проекта.
        @param cur_package: Узел пакета, в который происходит добавление.
        @param path: Текущая папка-пакет/py-модуль.
        """
        if self.isPackage(path):
            # Это пакет
            cur_node = icPrjPackage(cur_package)
            # Установить имя
            name = os.path.split(path)[1]
            cur_node.name = name
            cur_package.addChild(cur_node)
            # Обработка подпапок
            all_path_list = self._getPrjFileList(path)
            for py_path in all_path_list:
                self.buildPyTree(cur_node, py_path)

        elif self.isTemplateModule(path):
            # Это модуль шаблона
            cur_node = icPrjTemplateModule(cur_package)
            # Установить имя
            name = os.path.splitext(os.path.split(path)[1])[0]
            cur_node.name = name
            cur_package.addChild(cur_node)
            
        elif self.isInterfaceModule(path):
            # Это интерфейсный модуль
            cur_node = icPrjInterfaceModule(cur_package)
            # Установить имя
            name = os.path.splitext(os.path.split(path)[1])[0]
            cur_node.name = name
            cur_package.addChild(cur_node)
            
        elif self.isResourceModule(path):
            # Это ресурсный модуль
            cur_node = icPrjResourceModule(cur_package)
            # Установить имя
            name = os.path.splitext(os.path.split(path)[1])[0]
            cur_node.name = name
            cur_package.addChild(cur_node)
            
        elif self.isImageModule(path):
            # Это модуль библиотеки образов
            cur_node = icPrjImageModule(cur_package)
            # Установить имя
            name = os.path.splitext(os.path.split(path)[1])[0]
            cur_node.name = name
            cur_package.addChild(cur_node)

        elif self.isFBModule(path):
            # Это модуль форм wxFormBuilder
            cur_node = icPrjFBModule(cur_package)
            # Установить имя
            name = os.path.splitext(os.path.split(path)[1])[0]
            cur_node.name = name
            cur_package.addChild(cur_node)

        elif self.isXRCModule(path):
            # Это модуль форм, сгенерированных утилитой pywxrc (из XRC ресурса).
            cur_node = icPrjXRCModule(cur_package)
            # Установить имя
            name = os.path.splitext(os.path.split(path)[1])[0]
            cur_node.name = name
            cur_package.addChild(cur_node)

        elif self.isModule(path):
            # Это модуль
            cur_node = icPrjModule(cur_package)
            # Установить имя
            name = os.path.splitext(os.path.split(path)[1])[0]
            cur_node.name = name
            cur_package.addChild(cur_node)

        elif self.isFBP(path):
            # Это FBP файл
            cur_node = prj_fb.icPrjWXFormBuilderProject(cur_package)
            # Установить имя
            name = os.path.splitext(os.path.split(path)[1])[0]
            cur_node.name = name
            cur_package.addChild(cur_node)

        elif self.isXRC(path):
            # Это XRC файл
            cur_node = prj_xrc.icPrjXRCResource(cur_package)
            # Установить имя
            name = os.path.splitext(os.path.split(path)[1])[0]
            cur_node.name = name
            cur_package.addChild(cur_node)

        elif self.isWXCP(path):
            # Это WXCP файл
            cur_node = prj_wxcp.icPrjWXCrafterProject(cur_package)
            # Установить имя
            name = os.path.splitext(os.path.split(path)[1])[0]
            cur_node.name = name
            cur_package.addChild(cur_node)
        else:
            log.warning(u'Не определен тип модуля <%s>' % path)

    def edit(self):
        """
        Редактирование пакета(редактирование __init__.py файла).
        """
        ide = self.getRoot().getParent().getIDE()
        if ide:
            py_file = os.path.join(os.path.dirname(self.getRoot().getPrjFileName()),
                                   '__init__.py')
            # Если файл не открыт, то открыть его
            if not ide.selectFile(py_file):
                return ide.openFile(py_file, True, bReadonly=self.readonly)
            return True
        else:
            log.warning(u'Не определен IDE для редактирования модуля')
            
    def unlockAllPyFiles(self):
        """
        Разблокировать все *.py файлы.
        """
        for child in self.children:
            child.unlockAllPyFiles()

    def getPath(self):
        """
        Путь к папке модулей/проекта.
        """
        return os.path.dirname(self.getRoot().getPrjFileName())


class icPrjPackage(prj_node.icPrjFolder):
    """
    Пакет модулей.
    """
    def __init__(self, parent=None):
        """
        Конструктор.
        """
        prj_node.icPrjFolder.__init__(self, parent)
        self.img = imglib.imgPackageClose
        self.img_extended = imglib.imgPackageOpen
        self.description = u'Пакет'
        self.name = u'package'
        self.include_nodes = [icPrjModule,
                              prj_fb.icPrjWXFormBuilderProject,
                              prj_xrc.icPrjXRCResource,
                              prj_wxcp.icPrjWXCrafterProject,
                              prj_resource.icPrjTabRes, prj_resource.icPrjDBRes,
                              prj_resource.icPrjFrmRes, prj_resource.icPrjWinRes,
                              prj_resource.icPrjMenuRes, prj_resource.icPrjTemplate,
                              prj_resource.icPrjMethod]
        self.include_folder = icPrjPackage

    def onNodePopup(self, event):
        """
        Вызов всплывающего меню узла.
        """
        from . import menuModNode

        popup_menu = menuModNode.icMenuModNode(self)
        popup_menu.Popup(wx.GetMousePosition(), self._root.getParent())

    def create(self, new_name=None):
        """
        Создание пакета.
        @param new_name: Указание нового имени созданного узла.
        """
        # Ввести наименование при создании
        if not new_name:
            new_name = ic_dlg.icTextEntryDlg(self.getPrjTreeCtrl(), title=u'НАИМЕНОВАНИЕ',
                                             prompt_text=u'Введите наименование пакета', default_value=self.name)
        if new_name:
            self.name = new_name

        try:
            # Создание пакета ведет к созданию пакета Python.
            path = self.getPath()
            ok = self.getRoot().prj_res_manager.addPackage(path)
            self.getRoot().save()
            return ok
        except:
            log.fatal(u'Ошибка создания пакета <%s>' % self.name)
            return False
        
    def rename(self, old_name, new_name):
        """
        Переименование пакета.
        """
        old_path = self.getPath()
        self.name = new_name
        new_path = self.getPath()
        if os.path.isdir(old_path):
            os.rename(old_path, new_path)
        # Для синхронизации дерева проекта
        self.getRoot().save()
        return True
        
    def getPath(self, cur_path=None):
        """
        Путь пакета.
        """
        if cur_path is None:
            cur_path = self.name
        if issubclass(self._Parent.__class__, icPrjPackage):
            cur_path = os.path.join(self._Parent.getPath(), cur_path)
        elif issubclass(self._Parent.__class__, icPrjModules):
            cur_path = ic_file.AbsolutePath(os.path.join('.', self.getRoot().name, cur_path),
                                            os.path.split(os.path.dirname(self.getRoot().getPrjFileName()))[0])
        # log.debug(u'Путь до пакета <%s>' % cur_path)
        return cur_path
            
    def getModuleName(self):
        """
        Имя __init__ файла.
        """
        return '__init__'
        
    def edit(self):
        """
        Редактирование пакета(редактирование __init__.py файла).
        """
        ide = self.getRoot().getParent().getIDE()
        if ide:
            pack_dir = self.getPath()
            py_file = os.path.join(pack_dir, '__init__.py')
            # Сначала разблокировать все модули
            self.getRoot().unlockAllPyFilesInIDE()
            if not ide.selectFile(py_file):
                # Заблокировать файл
                parent_pack = os.path.basename(os.path.dirname(pack_dir))
                ic_res.lockRes(self.name, parent_pack, 'py',
                               self.getRoot().lock_dir)
                return ide.openFile(py_file, True, bReadonly=self.readonly)
            return True
        else:
            log.warning(u'Не определен IDE для редактирования модуля')

    def unlockAllPyFiles(self):
        """
        Разблокировать все *.py файлы.
        """
        # Разблокировать себя
        py_file = os.path.join(self.getPath(), '__init__.py')
        self.getRoot().unlockPyFileInIDE(py_file)
        # Разблокировать все дочерние файлы/пакеты
        for child in self.children:
            child.unlockAllPyFiles()

    def delete(self):
        """
        Удалить пакет.
        """
        # Затем удалить из дерева
        prj_node.icPrjNode.delete(self)
        # И в конце удалить папку пакета, если она есть
        package = self.getPath()
        # Выгрузить из редакторов
        self.getRoot().getParent().getIDE().closeFile(os.path.join(package, '__init__.py'))

        # Удалить все блокировки
        self.getRoot().unlockAllPyFilesInIDE()

        if os.path.exists(package):
            shutil.rmtree(package, 1)
        # Для синхронизации дерева проекта
        self.getRoot().save()
            
    def cut(self):
        """
        Вырезать.
        """
        py_file = os.path.join(self.getPath(), '__init__.py')
        copy_py_file = self.getCopyModuleName()
        ic_file.icCopyFile(py_file, copy_py_file)
        me_node = prj_node.icPrjNode.cut(self)
        self.delete()
        return me_node
        
    def copy(self):
        """
        Копировать.
        """
        py_file = os.path.join(self.getPath(), '__init__.py')
        copy_node = prj_node.icPrjNode.copy(self)
        copy_py_file = copy_node.getCopyModuleName()
        ic_file.icCopyFile(py_file, copy_py_file)
        return copy_node
        
    def paste(self, node):
        """
        Вставить.
        @param node: Вставляемый узел.
        """
        # Можно вставлять толко модули или другие пакеты
        if issubclass(node.__class__, icPrjModule) or \
           issubclass(node.__class__, icPrjPackage):
            prj_node.icPrjNode.paste(self, node)

            mod_name = node.getModuleName()
            mod_path = node.getPath()
            # Есть уже модуль с таким именем?
            if self.getRoot().prj_res_manager.isModByName(mod_name):
                ic_dlg.icMsgBox(u'ВНИМАНИЕ!', 
                                u'Модуль <%s> уже существует!' % mod_name)
                return False
            # Добавить модуль в ресурс проекта
            node.getRoot().prj_res_manager.addModule(mod_name, mod_path)
            module_file_name = os.path.join(mod_path, mod_name+'.py')
            copy_module_file_name = node.getCopyModuleName()
            ok = False
            if os.path.exists(copy_module_file_name):
                ok = ic_file.icCopyFile(copy_module_file_name, module_file_name)
                os.remove(copy_module_file_name)
            
            # Для синхронизации дерева проекта
            node.getRoot().save()
            return ok
        return False

    def getCopyModuleName(self):
        return os.path.join(self.getPath(), '__init__.bak')


class icPrjModule(prj_node.icPrjNode):
    """
    Модуль/Функционал.
    """

    def __init__(self, parent=None):
        """
        Конструктор.
        """
        prj_node.icPrjNode.__init__(self, parent)
        self.description = u'Модуль'
        self.name = 'new_module'
        self.img = imglib.imgEdtModule

        # Расширение файла модуля
        self.ext = '.py'

    def getModuleName(self):
        return self.name
        
    def getModulePath(self):
        """
        Путь до модуля.
        """
        module_path = ''
        # Если родитель - пакет, то дабывить его в путь
        if issubclass(self._Parent.__class__, icPrjPackage):
            module_path = self._Parent.getPath()
        elif issubclass(self._Parent.__class__, icPrjModules):
            module_path = os.path.dirname(self.getRoot().getPrjFileName())
        # log.debug(u'Путь до модуля <%s>' % module_path)
        return module_path
        
    def getPath(self):
        return os.path.normpath(self.getModulePath())
        
    def getFullModuleFileName(self):
        return os.path.join(self.getPath(), self.getModuleName()+self.ext)
        
    def create(self, new_name=None):
        """
        Функция создания модуля.
        @param new_name: Указание нового имени созданного узла.
        """
        # Ввести наименование при создании
        if not new_name:
            new_name = ic_dlg.icTextEntryDlg(self.getPrjTreeCtrl(), title=u'НАИМЕНОВАНИЕ',
                                             prompt_text=u'Введите наименование модуля', default_value=self.name)
        if new_name:
            self.name = new_name

        mod_name = self.getModuleName()
        mod_path = self.getModulePath()
        # Есть уже модуль с таким именем?
        if self.getRoot().prj_res_manager.isModByName(mod_name):
            ic_dlg.icMsgBox(u'ВНИМАНИЕ!', 
                            u'Модуль <%s> уже существует!' % mod_name)
            return False
        # Добавить модуль в ресурс проекта
        self.getRoot().prj_res_manager.addModule(mod_name, mod_path)
        module_file_name = os.path.join(mod_path, mod_name+self.ext)
        ok = ic_res.CreatePyFile(module_file_name)
        # Для синхронизации дерева проекта
        self.getRoot().save()
        return ok
        
    def rename(self, old_name, new_name):
        """
        Переименование модуля.
        """
        old_path = self.getModulePath()
        old_py_file = os.path.join(old_path, old_name + self.ext)
        self.name = new_name
        new_path = self.getModulePath()
        new_py_file = os.path.join(new_path, new_name + self.ext)
        if os.path.isfile(old_py_file):
            os.rename(old_py_file, new_py_file)
            # Закрыть модуль для редактирования
            ide = self.getRoot().getParent().getIDE()
            ide.closeFile(old_py_file)
            # И опять открыть
            self.edit()
        # Для синхронизации дерева проекта
        self.getRoot().save()
        return True

    def edit(self):
        """
        Редактирование модуля.
        """
        # Определяем имя модуля
        py_dir = self.getModulePath()
        py_file = self.getFullModuleFileName()
        log.info(u'Редактирование модуля python <%s>' % py_file)

        # Определяем IDE
        ide = self.getRoot().getParent().getIDE()
        if ide:
            # Сначала разблокировать все модули
            self.getRoot().unlockAllPyFilesInIDE()
            if ide.isOpenedFile(py_file):
                ide.closeFile(py_file)
            else:
                parent_pack = os.path.basename(py_dir)
                # Если модуль заблокирован,
                # тогда открыть его только для просмотра
                if ic_res.isLockRes(self.name, parent_pack, 'py',
                                    self.getRoot().lock_dir):
                    lock_rec = ic_res.getLockResRecord(self.name, parent_pack,
                                                       'py', self.getRoot().lock_dir)

                    lock_user = lock_rec.get('user', u'Не определен') if lock_rec else u'Не определен'
                    lock_computer = lock_rec.get('computer', u'Не определен') if lock_rec else u'Не определен'
                    ic_dlg.icMsgBox(u'ВНИМАНИЕ!',
                                    u'Ресурс <%s> заблокирован пользователем <%s>. Компьютер: <%s>.' % (self.name, 
                                                                                                        lock_user,
                                                                                                        lock_computer))
                    self.readonly = True
                else:
                    # Заблокировать файл
                    ic_res.lockRes(self.name, parent_pack, 'py',
                                   self.getRoot().lock_dir)
                
            # Условие открытия в редакторе ресурса
            if self.isResClass(py_file):
                self.getRoot().getParent().res_editor.SetResource(self.name,
                                                                  py_dir, self.name, 'py', bEnable=True)

            return ide.openFile(py_file, True, bReadonly=self.readonly)
        else:
            log.warning(u'Не определен IDE для редактирования модуля')

        return False

    def onNodePopup(self, event):
        """
        Вызов всплывающего меню узла.
        """
        from . import menuModNode

        if not self.readonly:
            popup_menu = menuModNode.icMenuModNode(self)
            popup_menu.Popup(wx.GetMousePosition(), self._root.getParent())

    def unlockAllPyFiles(self):
        """ 
        Разблокировать все *.py файлы.
        """
        # Разблокировать себя
        py_file = os.path.join(self.getModulePath(),
                               self.getModuleName()+self.ext)
        self.getRoot().unlockPyFileInIDE(py_file)
            
    def delete(self):
        """
        Удалить модуль.
        """
        # ВОЗМОЖНО ЭТОТ МОДУЛЬ ПРОПИСАН КАК РЕСУРС!!!
        # Сначала удалить из файла *.pro
        self.getRoot().prj_res_manager.delRes(self.name, 'py')
        # Затем удалить из дерева
        prj_node.icPrjNode.delete(self)

        module_name = os.path.join(self.getModulePath(), self.name+self.ext)

        # Выгрузить из редакторов
        self.getRoot().getParent().getIDE().closeFile(module_name)
        res_file_name = self.getRoot().getParent().res_editor.GetResFileName()
        if res_file_name and ic_file.SamePathWin(module_name, res_file_name):
            self.getRoot().getParent().res_editor.CloseResource()
            
        # Удалить все блокировки
        self.getRoot().unlockAllPyFilesInIDE()

        # И в конце удалить папку пакета, если она есть
        if os.path.exists(module_name):
            # ВНИМАНИЕ! Удаляем файл, но оставляем его бекапную версию
            # для возможного восстановления!
            ic_file.icCreateBAKFile(module_name)
            os.remove(module_name)
        # Для синхронизации дерева проекта
        self.getRoot().save()

    def cut(self):
        """
        Вырезать.
        """
        module_name = os.path.join(self.getModulePath(),
                                   self.name+self.ext)
        ic_file.icChangeExt(module_name, '.bak')
        me_node = prj_node.icPrjNode.cut(self)
        self.delete()
        return me_node
        
    def copy(self):
        """
        Копировать.
        """
        module_name = os.path.join(self.getModulePath(),
                                   self.name+self.ext)
        copy_node = prj_node.icPrjNode.copy(self)
        copy_module_name = copy_node.getCopyModuleName()
        ic_file.icCopyFile(module_name, copy_module_name)
        return copy_node
        
    def paste(self, node):
        """
        Вставить.
        @param node: Вставляемый узел.
        """
        # Можно вставлять толко модули или другие пакеты
        if issubclass(node.__class__, icPrjModule) or \
           issubclass(node.__class__, icPrjPackage):
            prj_node.icPrjNode.paste(self, node)

            mod_name = node.getModuleName()
            mod_path = node.getPath()
            # Есть уже модуль с таким именем?
            if self.getRoot().prj_res_manager.isModByName(mod_name):
                ic_dlg.icMsgBox(u'ВНИМАНИЕ!', 
                                u'Модуль <%s> уже существует!' % mod_name)
                return False
            # Добавить модуль в ресурс проекта
            node.getRoot().prj_res_manager.addModule(mod_name, mod_path)
            module_file_name = os.path.join(mod_path, mod_name+self.ext)
            copy_module_file_name = node.getCopyModuleName()
            ok = False
            if os.path.exists(copy_module_file_name):
                ok = ic_file.icCopyFile(copy_module_file_name, module_file_name)
                os.remove(copy_module_file_name)
            # Для синхронизации дерева проекта
            node.getRoot().save()
            return ok
        return False
        
    def isResClass(self, module_filename):
        """
        Проверка, является ли указанный модуль ресурсным классом.
        @param module_filename: Имя файла модуля.
        @return: Возвращает True/False.
        """
        ok = False
        module_lines = None
        module_file = None
        try:
            module_file = open(module_filename, 'rt')
            module_lines = module_file.readlines()
            module_file.close()
            module_lines = [line[:-1].strip() for line in module_lines]
        except:
            if module_file:
                module_file.close()
        if module_lines:
            ok = INTERFACE_MODULE_SIGNATURE in module_lines
        return ok
        
    def getCopyModuleName(self):
        return os.path.join(self.getPath(), self.name+'.bak')
  
    def getPopupHelpText(self):
        """
        Получить текст всплывающей помощи.
        """
        module_filename = u''
        try:
            module_filename = os.path.join(self.getModulePath(),
                                           self.name+self.ext)
            module_name = os.path.splitext(os.path.basename(module_filename))[0]
            # module = imp.load_source(module_name, module_filename)
            module = ic.utils.impfunc.loadSource(module_name, module_filename)
            if hasattr(module, '__doc__'):
                if wx.Platform == '__WXGTK__':
                    return module.__doc__.strip()
                elif wx.Platform == '__WXMSW__':
                    return str(module.__doc__.strip())
            return None
        except:
            err_txt = u'Ошибка импорта модуля <%s>' % module_filename
            log.fatal(err_txt)
            return err_txt


class icPrjInterfaceModule(icPrjModule):
    """
    Интерфейсный модуль.
    """

    def __init__(self, parent=None):
        """
        Конструктор.
        """
        icPrjModule.__init__(self, parent)
        self.description = _('Interface module')
        self.name = 'IInterface'
        self.img = imglib.imgEdtInterface

    def getFullResFileName(self):
        """
        Полное имя файла ресурса.
        """
        return os.path.normpath(os.path.join(self.getModulePath(),
                                             self.getModuleName()+self.ext))
        
    def getViewer(self, parent):
        """
        Просмотрщик узла.
        """
        from . import icresviewer
        return icresviewer.icResPrjNodeViewer(parent, self)
        
    def getMyRes(self):
        """
        Получить ресурс узла.
        """
        module = ic.utils.impfunc.reloadSource('interface_module', self.getFullResFileName())
        return {module.ic_class_name: module.resource}
    

class icPrjTemplateModule(icPrjModule):
    """
    Модуль шаблона.
    """

    def __init__(self, parent=None):
        """
        Конструктор.
        """
        icPrjModule.__init__(self, parent)
        self.description = u'Модуль шаблона'
        self.name = 'CTemplate'
        self.img = imglib.imgEdtTemplate


class icPrjResourceModule(icPrjModule):
    """
    Ресурсный модуль.
    """

    def __init__(self, parent=None):
        """
        Конструктор.
        """
        icPrjModule.__init__(self, parent)
        self.description = u'Модуль ресурса'
        self.name = 'res_module'
        self.img = imglib.imgEdtResModule


class icPrjImageModule(icPrjModule):
    """
    Модуль библиотеки образов.
    """

    def __init__(self, parent=None):
        """
        Конструктор.
        """
        icPrjModule.__init__(self, parent)
        self.description = u'Модуль библиотеки образов'
        self.name = 'img_module'
        self.img = imglib.imgEdtImgModule

    def getViewer(self, parent):
        """
        Просмотрщик узла.
        """
        from . import icimgmoduleviewer
        return icimgmoduleviewer.icImgModulePrjNodeViewer(parent, self)

    def edit(self):
        """
        Редактирование модуля.
        """
        ic_dlg.icWarningBox(u'ПРЕДУПРЕЖДЕНИЕ',
                            u'''Редактирование модуля библиотеки образов запрещено.
Модули библиотеки образов генерируются в редакторе библиотеки образов.''')


class icPrjFBModule(icPrjModule, wxfb_manager.icWXFormBuilderManager):
    """
    Модуль форм wxFormBuilder.
    """

    def __init__(self, parent=None):
        """
        Конструктор.
        """
        icPrjModule.__init__(self, parent)
        self.description = u'Модуль форм wxFormBuilder'
        self.name = 'fb_module'
        self.img = imglib.imgForm

        # self.bReadonly = True

    def edit(self):
        """
        Редактирование модуля.
        """
        ic_dlg.icWarningBox(u'ПРЕДУПРЕЖДЕНИЕ',
                            u'''Редактирование модуля форм wxFormBuilder запрещено.
Модули форм генерируются в среде wxFormBuilder.''')

    def onNodePopup(self, event):
        """
        Вызов всплывающего меню узла.
        """
        if not self.readonly:
            popup_menu = flatmenu.FlatMenu()
            ctrl = self._root.getParent()

            popup_menuitem_id = wx.NewId()
            item = flatmenu.FlatMenuItem(popup_menu, popup_menuitem_id,
                                         u'Удалить модуль формы', u'Удалить модуль формы',
                                         normalBmp=imglib.imgTrash)
            popup_menu.AppendItem(item)
            ctrl.Bind(wx.EVT_MENU, self.onDelFormModuleMenuItem, id=popup_menuitem_id)

            popup_menu.AppendSeparator()

            popup_menuitem_id = wx.NewId()
            item = flatmenu.FlatMenuItem(popup_menu, popup_menuitem_id,
                                         u'Сгенерировать модуль формы...', u'Сгенерировать модуль формы...',
                                         normalBmp=imglib.imgPy)
            popup_menu.AppendItem(item)
            ctrl.Bind(wx.EVT_MENU, self.onGenFormModuleMenuItem, id=popup_menuitem_id)

            popup_menuitem_id = wx.NewId()
            item = flatmenu.FlatMenuItem(popup_menu, popup_menuitem_id,
                                         u'Адаптация модуля форм wxFormBuilder', u'Адаптация модуля форм wxFormBuilder',
                                         normalBmp=imglib.imgConvert)
            popup_menu.AppendItem(item)
            ctrl.Bind(wx.EVT_MENU, self.onAdaptFormModuleMenuItem, id=popup_menuitem_id)

            popup_menu.Popup(wx.GetMousePosition(), ctrl)

    def onDelFormModuleMenuItem(self, event):
        """
        Удаление модуля формы.
        """
        self.delete()
        event.Skip()

    def onGenFormModuleMenuItem(self, event):
        """
        Запуск генерации модуля формы.
        """
        from ic.utils import py_gen

        fb_py_module_filename = self.getFullModuleFileName()
        py_gen.genPyForm_by_wxFBModule(fb_py_module_filename)

        prj_root = self.getRoot()
        prj_root.openPrj(prj_root.getPrjFileName())
        prj_root.getParent().Refresh()
        event.Skip()

    def onAdaptFormModuleMenuItem(self, event):
        """
        Запуск адаптации модуля формы wxFormBuilder.
        """
        fb_py_module_filename = self.getFullModuleFileName()
        result = self.adaptation_form_py(fb_py_module_filename)
        if not result:
            ic_dlg.icWarningBox(u'ОШИБКА', u'Ошибка адаптации модуля формы wxFormBuilder')
        else:
            ic_dlg.icMsgBox(u'АДАПТАЦИЯ', u'Адаптация модуля <%s> прошла успешно' % fb_py_module_filename)
        event.Skip()


class icPrjXRCModule(icPrjModule):
    """
    Модуль форм, сгенерированных утилитой pywxrc (из XRC ресурса).
    """

    def __init__(self, parent=None):
        """
        Конструктор.
        """
        icPrjModule.__init__(self, parent)
        self.description = u'Модуль форм, сгенерированных утилитой pywxrc (из XRC ресурса)'
        self.name = 'xrc_module'
        self.img = imglib.imgForm

        # self.bReadonly = True

    def edit(self):
        """
        Редактирование модуля.
        """
        ic_dlg.icWarningBox(u'ПРЕДУПРЕЖДЕНИЕ',
                            u'''Редактирование модуля форм, сгенерированных утилитой pywxrc (из XRC ресурса), запрещено.
Модули форм генерируются средствами дизайнера XRC файла.''')

    def onNodePopup(self, event):
        """
        Вызов всплывающего меню узла.
        """
        if not self.readonly:
            popup_menu = flatmenu.FlatMenu()
            ctrl = self._root.getParent()

            popup_menuitem_id = wx.NewId()
            item = flatmenu.FlatMenuItem(popup_menu, popup_menuitem_id,
                                         u'Удалить модуль формы', u'Удалить модуль формы',
                                         normalBmp=imglib.imgTrash)
            popup_menu.AppendItem(item)
            ctrl.Bind(wx.EVT_MENU, self.onDelFormModuleMenuItem, id=popup_menuitem_id)

            popup_menu.Popup(wx.GetMousePosition(), ctrl)

    def onDelFormModuleMenuItem(self, event):
        """
        Удаление модуля формы.
        """
        self.delete()
        event.Skip()
